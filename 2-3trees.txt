Store level with each node which is the height of the corresponding 2-3 node

if a node has the same level as its parent we'll draw them next to each other

if a node has the same level as its right chilld, the two nodes together make a 3node
otherwise its a 2 node

* only 2nodes and 3nodes
* levels match the heights in the 2-3 tree
* 2-3 tree is perfectly balanced

the level of a child must be either equal to the level of its parent or
one less than the level of its parent

if a node has the same level as its child, it must be the root of a 3node

* a node's level must be greater than its left child: level(node) > level(node.left)
* and also greater than its right-right grandchild: level(node) > level(node.right.right)

level of null = 0
for each node in the tree:
  * the node's children must have a level equal to or one less than the node itself
  * level(node) > level(node.left) (x <-- y not allowed)
  * any leaf node has level 1
  * we also have the normal bst invariant


INSERTION
new node is a leaf -> level 1

case1: skew
  * inserted into the left of a 2node, breaking the invariant
  * solve using right rotation
  * use whenever the new node is the left child of its parent

case2: split
  * insertion created a 4node which we can split into 2nodes
  * y's level increases - may break the invariant one level up
  * continue up recursively

all other cases: skew and split
first skew if left child is bad
then split if the right grandchild is bad

DELETION
  * lmao learn it yourself wtf u think we gonna teach u everything??
